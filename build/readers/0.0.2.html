<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>MBDB Loader</title>

<!-- Raw inflate support -->
<script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>

<style>
  body {
    background:#0b0b0b;
    color:#d0d0d0;
    font-family:monospace;
    white-space:pre-wrap;
  }
</style>
</head>
<body>
<pre id="log" style="white-space: pre-wrap; max-height: 500px; overflow-y: auto; background:#111; color:#0f0; padding:10px;"></pre>
<script>
(async function main() {
  const BASE = "https://theredmineword.github.io/map/build/";
  const logEl = document.getElementById("log");

  const appendLog = (msg) => {
    if (!logEl) return;
    logEl.textContent += msg + "\n";
    logEl.scrollTop = logEl.scrollHeight; // auto scroll
  };

  // Custom log functions
  const log = (...args) => {
    console.log(...args);
    appendLog(args.map(a => (typeof a === "object" ? JSON.stringify(a, null, 2) : a)).join(" "));
  };

  const err = (...args) => {
    console.error(...args);
    appendLog(args.map(a => (typeof a === "object" ? JSON.stringify(a, null, 2) : a)).join(" "));
  };

  function u8(hex) {
    return [...hex].map(c => c.charCodeAt(0));
  }

  function tryDecompress(buf) {
    const tries = [
      () => pako.inflateRaw(buf),
      () => pako.ungzip(buf),
      () => pako.inflate(buf),
      () => buf
    ];

    for (const fn of tries) {
      try {
        const out = fn();
        if (out && out.length) return out;
      } catch (_) {}
    }
    return null;
  }

  function findAll(hay, needle) {
    const hits = [];
    let i = 0;
    while ((i = hay.indexOf(needle, i)) !== -1) {
      hits.push(i);
      i += needle.length;
    }
    return hits;
  }

  log("[INFO] Fetching info…");
  const info = await fetch(BASE + "info?jam=" + Math.random()).then(r => r.text());
  const [commitLine, fragmentLine] = info.trim().split("\n");

  const commit = commitLine.trim();
  const parts = fragmentLine.match(/frg\.(\d+)/g) || ["frg.0"];
  const fragmentCount = parts.length;

  log("[INFO] Commit:", commit);
  log("[INFO] Fragments:", fragmentCount);

  let merged = new Uint8Array();

  for (let i = 0; i < fragmentCount; i++) {
    const url = `${BASE}commits/frg.${i}.MBDB?commit=${commit}`;
    log("[INFO] Fetching", url);

    const r = await fetch(url);
    const buf = new Uint8Array(await r.arrayBuffer());

    const tmp = new Uint8Array(merged.length + buf.length);
    tmp.set(merged);
    tmp.set(buf, merged.length);
    merged = tmp;
  }

  log("[INFO] Merged bytes:", merged.length);
  log("[INFO] Decompressing merged blob…");

  let data = tryDecompress(merged);
  if (!data) {
    err("[FATAL] Cannot decompress merged blob");
    return;
  }

  log("[INFO] Decompressed size:", data.length);

  const text = new TextDecoder("latin1").decode(data);

  const START = "AUG\n";
  const END = "\nUAG";

  const starts = findAll(text, START);

  log("[INFO] Records found:", starts.length);

  starts.forEach((pos, idx) => {
    try {
      const end = text.indexOf(END, pos);
      if (end === -1) return;

      const block = text.slice(pos + START.length, end);
      const metaEnd = block.indexOf("#$#$====== 'BYTES'");
      if (metaEnd === -1) return;

      const meta = block.slice(0, metaEnd).trim();
      const raw = block.slice(metaEnd + 18);

      log(`\n[MBDB] Record #${idx}`);
      log("[META]\n" + meta);

      const compressed = /Compressed=1/.test(meta);

      let payload = new Uint8Array([...raw].map(c => c.charCodeAt(0)));

      if (compressed) {
        log("[INFO] Payload compressed → attempting decompression");
        const out = tryDecompress(payload);
        if (!out) {
          err("[ERROR] Payload decompression failed → skipping record");
          return;
        }
        payload = out;
      }

      log("[BYTES] final size:", payload.length);
      \\ log("[BYTES] raw:", payload);

      
      if (/JAVASCRIPT_SOURCE/.test(meta)) {
        const src = new TextDecoder().decode(payload);
        log("[EXEC] JavaScript source loaded");
        // eval(src); // intentionally commented
      }

    } catch (e) {
      err("[ERROR] Record parse failed → skipped", e);
    }
  });

})();
</script>
</body>
</html>
