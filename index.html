<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">

<title>Temponary MBMB
</title>
<script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
<style>
body {
  background:#0b0b0b;
  color:#d0d0d0;
  font-family:monospace;
}
#log {
  white-space:pre-wrap;
  background:#111;
  color:#0f0;
  padding:10px;

}

  #logEl {
  font-family: monospace;
  white-space: pre;
  overflow-x: auto;
  box-sizing: border-box;
  }

  

</style>
</head>
<body>
<pre id="log"></pre>

<script>
/* ================= GLOBAL ================= */
window.vars = {};
window.MBDB = { ready:false };

const logEl = document.getElementById("log");
const log = (...a) => {
  // logEl.textContent += a.join(" ") + "\n";
logEl.textContent = a.join(" ") + "\n" + logEl.textContent;

  logEl.scrollTop = logEl.scrollHeight;

};
  const logascii = (ascii) => {
  // Ensure full viewport width
  logEl.style.width = "100vw";
  logEl.style.maxWidth = "100vw";

  // Prevent wrapping
  logEl.style.whiteSpace = "pre";
  logEl.style.overflowX = "auto";

  // Prepend ASCII art (same behavior as log)
  logEl.textContent = ascii + "\n\n" + logEl.textContent;

  // Keep scrolled to top of newest entry
  logEl.scrollTop = 0;
};

const err = (...a) => log("[ERROR]", ...a);

const decoder = new TextDecoder("utf-8");

let initsrc = () => err("Error: empty INIT_SRC_INIT script");

  logascii("  ____                                                    \r\n |  _ \\       _                                           \r\n | |_) |_   _(_)                                          \r\n |  _ <| | | |                                            \r\n | |_) | |_| |_                                           \r\n |____/ \\__, (_)  __ _                                  _ \r\n |  __ \\ __/ |  \\/  (_)                                | |\r\n | |  | |___/| \\  / |_ _ __   _____      _____  _ __ __| |\r\n | |  | | '__| |\\/| | | '_ \\ / _ \\ \\ /\\ / / _ \\| '__/ _` |\r\n | |__| | |  | |  | | | | | |  __/\\ V  V / (_) | | | (_| |\r\n |_____/|_|  |_|  |_|_|_| |_|\\___| \\_/\\_/ \\___/|_|  \\__,_|\r\n                                                          \r\n                                                          ");
/* ================= UTILS ================= */

function tryDecompress(buf) {
  try { return pako.inflateRaw(buf); } catch {}
  try { return pako.ungzip(buf); } catch {}
  try { return pako.inflate(buf); } catch {}
  return null;
}

function base64ToBytes(b64) {
  const bin = atob(b64);
  const out = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; i++) {
    out[i] = bin.charCodeAt(i);
  }
  return out;
}

/* ================= FETCH ================= */

async function fetchInfo() {
  const url =
    "https://theredmineword.github.io/map/build/info?jam=" + Math.random();
  log("[INFO]", url);
  return (await fetch(url)).text();
}

async function fetchFragments() {
  const lines = (await fetchInfo()).trim().split("\n");
  const commit = lines[0];

  let total = 0;
  const urls = [];

  for (let i = 1; i < lines.length; i++) {
    const [path, size] = lines[i].split(",");
    if (!path) continue;

    total += Number(size || 0);

    const u = new URL(
      path.trim(),
      "https://theredmineword.github.io/map/build/"
    );
    u.searchParams.set("commit", commit);
    urls.push(u.toString());
  }

  return { urls, total };
}

async function download(url, state) {
  const res = await fetch(url);
  const reader = res.body.getReader();
  const chunks = [];
  let len = 0;

  while (true) {
    const { done, value } = await reader.read();
    if (done) break;
    chunks.push(value);
    len += value.length;
    state.done += value.length;
    log(
      `Downloading ${(state.done / state.total * 100).toFixed(2)}% | Bytes ${state.done}/${state.total}`
    );
  }

  const out = new Uint8Array(len);
  let off = 0;
  for (const c of chunks) {
    out.set(c, off);
    off += c.length;
  }
  return out;
}

/* ================= MAIN ================= */

(async () => {
  const { urls, total } = await fetchFragments();
  const state = { done: 0, total };
  const parts = [];

  for (const u of urls) {
    log("[DL]", u);
    parts.push(await download(u, state));
  }

  const size = parts.reduce((s, b) => s + b.length, 0);
  const merged = new Uint8Array(size);
  let off = 0;
  for (const b of parts) {
    merged.set(b, off);
    off += b.length;
  }

  const top = tryDecompress(merged);
  const text = decoder.decode(top || merged);

  parseMBDB(text);

  /* ===== DEAD LAST: INIT EXEC ===== */


// if (Array.isArray(window.vars.INIT_SRC_INIT)) {
 //   log("\n[EVAL INIT] FOUND", window.vars.INIT_SRC_INIT.length, "scripts");
   // for (const src of window.vars.INIT_SRC_INIT) {
   //     try {
   //         eval(src);
   //     } catch (e) {
   //         err("INIT eval failed:", e);
  //      }
 //   }

//   initsrc = window.vars.INIT_SRC_INIT?.[0];
//  console.log(window.vars.INIT_SRC_INIT?.[0]);
//  log("[INIT] INIT_SRC_INIT stored");
//}


  window.MBDB.ready = true;
  log("\n[DONE] vars keys:", Object.keys(window.vars));
})();

/* ================= MBDB PARSER ================= */

function parseMBDB(text) {
  const START = "AUG\n";
  const END = "\nUAG";
  const BYTES = "#$#$====== 'BYTES'\n";

  let pos = 0;
  let count = 0;

  while ((pos = text.indexOf(START, pos)) !== -1) {
    const end = text.indexOf(END, pos);
    if (end === -1) break;

    const block = text.slice(pos + START.length, end);
    pos = end + END.length;

    const bIdx = block.indexOf(BYTES);
    if (bIdx === -1) continue;

    count++;

    const meta = block.slice(0, bIdx).trim();
    const raw = block.slice(bIdx + BYTES.length);

    log("\n[MBDB] RECORD");
    log("[META]\n" + meta);

    const typeMatch = meta.match(/^Type=([^\r\n]+)/m);
    if (!typeMatch) continue;

    let type = typeMatch[1].trim();
    const compressed = /Compressed=1/.test(meta);

    const bytes = new Uint8Array(raw.length);
    for (let i = 0; i < raw.length; i++) {
      bytes[i] = raw.charCodeAt(i) & 0xff;
    }

    let payloadBytes = bytes;

    if (compressed) {
      const b64 = decoder.decode(bytes).trim();
      const dec = tryDecompress(base64ToBytes(b64));
      if (!dec) {
        err("Decompression failed:", type);
        continue;
      }
      payloadBytes = dec;
    }

    const payloadStr = decoder.decode(payloadBytes);
    log("[PAYLOAD]", payloadStr.slice(0, 200) + (payloadStr.length > 200 ? "..." : ""));

    if (type.startsWith("MAP_BLOB")) type = "MAP_BLOB";

    if (type === "INIT_SRC_INIT") {
      (window.vars.INIT_SRC_INIT ??= []).push(payloadStr);
    } else if (type === "MAP_BLOB") {
      (window.vars.MAP_BLOB ??= []).push(payloadStr);
    } else {
      if (type in window.vars) {
        if (!Array.isArray(window.vars[type])) {
          window.vars[type] = [window.vars[type]];
        }
        window.vars[type].push(payloadStr);
      } else {
        window.vars[type] = payloadStr;
      }
    }
  }

  log("[MBDB] records parsed:", count);


  log("[FIN]");
  eval(window.vars.INIT_SRC_INIT?.[0]);

}

</script>
</body>
</html>
